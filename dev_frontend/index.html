<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SimulateDev</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            max-width: 900px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
            color: #333;
        }
        .container {
            background: white;
            padding: 30px;
            border-radius: 12px;
            box-shadow: 0 2px 20px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }
        h1 {
            text-align: center;
            margin-bottom: 30px;
            color: #2c3e50;
        }
        
        /* Authentication Styles */
        .auth-container {
            text-align: center;
            padding: 40px;
        }
        .auth-container h2 {
            margin-bottom: 20px;
            color: #2c3e50;
        }
        .auth-container p {
            margin-bottom: 30px;
            color: #666;
            line-height: 1.6;
        }
        .github-login-btn {
            background: #24292e;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            display: inline-flex;
            align-items: center;
            gap: 8px;
            text-decoration: none;
            transition: background-color 0.3s ease;
        }
        .github-login-btn:hover {
            background: #1a1e22;
        }
        .user-info {
            display: flex;
            align-items: center;
            justify-content: space-between;
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
        }
        .user-details {
            display: flex;
            align-items: center;
            gap: 12px;
        }
        .user-avatar {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            border: 2px solid #e9ecef;
        }
        .user-name {
            font-weight: 600;
            color: #2c3e50;
        }
        .logout-btn {
            background: #dc3545;
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }
        .logout-btn:hover {
            background: #c82333;
        }
        
        .step {
            display: none;
        }
        .step.active {
            display: block;
        }
        .step-indicator {
            display: flex;
            justify-content: center;
            margin-bottom: 30px;
        }
        .step-item {
            display: flex;
            align-items: center;
            margin: 0 10px;
            color: #bdc3c7;
        }
        .step-item.active {
            color: #3498db;
            font-weight: 600;
        }
        .step-item.completed {
            color: #27ae60;
        }
        .step-number {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            background: #bdc3c7;
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-right: 8px;
            font-weight: 600;
        }
        .step-item.active .step-number {
            background: #3498db;
        }
        .step-item.completed .step-number {
            background: #27ae60;
        }
        .form-group {
            margin-bottom: 20px;
        }
        label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #2c3e50;
        }
        input, select, textarea {
            width: 100%;
            padding: 12px;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            font-size: 16px;
            transition: border-color 0.3s ease;
        }
        input:focus, select:focus, textarea:focus {
            outline: none;
            border-color: #3498db;
            box-shadow: 0 0 0 3px rgba(52, 152, 219, 0.1);
        }
        button {
            background: #3498db;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }
        button:hover:not(:disabled) {
            background: #2980b9;
        }
        button:disabled {
            background: #bdc3c7;
            cursor: not-allowed;
        }
        button.secondary {
            background: #95a5a6;
        }
        button.secondary:hover {
            background: #7f8c8d;
        }
        .search-box {
            position: relative;
            margin-bottom: 20px;
        }
        .search-box input {
            padding-right: 40px;
        }
        .search-icon {
            position: absolute;
            right: 12px;
            top: 50%;
            transform: translateY(-50%);
            color: #7f8c8d;
        }
        .issues-list {
            max-height: 400px;
            overflow-y: auto;
            border: 1px solid #e9ecef;
            border-radius: 8px;
        }
        .issue-item {
            padding: 16px;
            border-bottom: 1px solid #f1f3f4;
            cursor: pointer;
            transition: background-color 0.2s ease;
        }
        .issue-item:last-child {
            border-bottom: none;
        }
        .issue-item:hover {
            background-color: #f8f9fa;
        }
        .issue-item.selected {
            background-color: #e3f2fd;
            border-left: 4px solid #2196f3;
        }
        .issue-title {
            font-weight: 600;
            color: #2c3e50;
            margin-bottom: 8px;
        }
        .issue-meta {
            font-size: 14px;
            color: #7f8c8d;
            margin-bottom: 8px;
        }
        .issue-body {
            color: #555;
            line-height: 1.4;
            margin-bottom: 8px;
        }
        .issue-labels {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
        }
        .label {
            background: #e9ecef;
            color: #495057;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: 500;
        }
        .progress {
            margin: 20px 0;
        }
        .status {
            font-weight: 600;
            margin-bottom: 10px;
            color: #2c3e50;
        }
        .progress-bar {
            width: 100%;
            height: 8px;
            background: #e9ecef;
            border-radius: 4px;
            overflow: hidden;
        }
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #3498db, #2ecc71);
            width: 0%;
            transition: width 0.3s ease;
        }
        .pr-link {
            display: none;
            margin-top: 20px;
            padding: 20px;
            background: #d4edda;
            border: 1px solid #c3e6cb;
            border-radius: 8px;
            color: #155724;
        }
        .pr-link a {
            color: #155724;
            font-weight: 600;
            text-decoration: none;
        }
        .pr-link a:hover {
            text-decoration: underline;
        }
        .error {
            display: none;
            margin-top: 20px;
            padding: 15px;
            background: #f8d7da;
            border-radius: 8px;
            color: #721c24;
        }
        .loading {
            text-align: center;
            padding: 40px;
            color: #7f8c8d;
        }
        .empty-state {
            text-align: center;
            padding: 40px;
            color: #7f8c8d;
        }
        
        /* Autocomplete Styles */
        .autocomplete-container {
            position: relative;
            width: 100%;
        }
        .autocomplete-dropdown {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: white;
            border: 1px solid #e9ecef;
            border-top: none;
            border-radius: 0 0 8px 8px;
            max-height: 300px;
            overflow-y: auto;
            z-index: 1000;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            display: none;
        }
        .autocomplete-dropdown.show {
            display: block;
        }
        .autocomplete-item {
            padding: 12px 16px;
            cursor: pointer;
            border-bottom: 1px solid #f1f3f4;
            transition: background-color 0.2s ease;
        }
        .autocomplete-item:last-child {
            border-bottom: none;
        }
        .autocomplete-item:hover, .autocomplete-item.highlighted {
            background-color: #f8f9fa;
        }
        .autocomplete-item.selected {
            background-color: #e3f2fd;
        }
        .repo-name {
            font-weight: 600;
            color: #2c3e50;
            margin-bottom: 4px;
        }
        .repo-description {
            font-size: 14px;
            color: #7f8c8d;
            line-height: 1.3;
        }
        .repo-meta {
            font-size: 12px;
            color: #95a5a6;
            margin-top: 4px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .language-indicator {
            display: inline-flex;
            align-items: center;
            gap: 4px;
        }
        .language-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #95a5a6;
        }
        .autocomplete-loading {
            padding: 16px;
            text-align: center;
            color: #7f8c8d;
            font-size: 14px;
        }
        .autocomplete-no-results {
            padding: 16px;
            text-align: center;
            color: #7f8c8d;
            font-size: 14px;
        }
        
        /* Confetti Animation Styles */
        .confetti-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            pointer-events: none;
            z-index: 9999;
            overflow: hidden;
        }
        
        .confetti-piece {
            position: absolute;
            width: 10px;
            height: 10px;
            background: #ff6b6b;
            animation: confetti-fall 3s linear forwards;
        }
        
        .confetti-piece:nth-child(2n) { background: #4ecdc4; }
        .confetti-piece:nth-child(3n) { background: #45b7d1; }
        .confetti-piece:nth-child(4n) { background: #96ceb4; }
        .confetti-piece:nth-child(5n) { background: #feca57; }
        .confetti-piece:nth-child(6n) { background: #ff9ff3; }
        .confetti-piece:nth-child(7n) { background: #54a0ff; }
        .confetti-piece:nth-child(8n) { background: #5f27cd; }
        
        @keyframes confetti-fall {
            0% {
                transform: translateY(-100vh) rotate(0deg);
                opacity: 1;
            }
            100% {
                transform: translateY(100vh) rotate(720deg);
                opacity: 0;
            }
        }
        
        .confetti-piece.square {
            border-radius: 0;
        }
        
        .confetti-piece.circle {
            border-radius: 50%;
        }
        
        .confetti-piece.triangle {
            width: 0;
            height: 0;
            background: transparent;
            border-left: 5px solid transparent;
            border-right: 5px solid transparent;
            border-bottom: 10px solid #ff6b6b;
        }
        
        .confetti-piece.triangle:nth-child(2n) { border-bottom-color: #4ecdc4; }
        .confetti-piece.triangle:nth-child(3n) { border-bottom-color: #45b7d1; }
        .confetti-piece.triangle:nth-child(4n) { border-bottom-color: #96ceb4; }
        .confetti-piece.triangle:nth-child(5n) { border-bottom-color: #feca57; }
        .confetti-piece.triangle:nth-child(6n) { border-bottom-color: #ff9ff3; }
        .confetti-piece.triangle:nth-child(7n) { border-bottom-color: #54a0ff; }
        .confetti-piece.triangle:nth-child(8n) { border-bottom-color: #5f27cd; }
    </style>
</head>
<body>
    <div class="container">
        <h1>üöÄ SimulateDev</h1>
        
        <!-- Authentication Section -->
        <div id="auth-section" class="auth-container">
            <h2>Welcome to SimulateDev</h2>
            <p>Connect your GitHub account to start automating your development workflow with AI coding agents.</p>
            <a href="#" onclick="loginWithGitHub()" class="github-login-btn">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
                    <path d="M12 0C5.37 0 0 5.37 0 12c0 5.31 3.435 9.795 8.205 11.385.6.105.825-.255.825-.57 0-.285-.015-1.23-.015-2.235-3.015.555-3.795-.735-4.035-1.41-.135-.345-.72-1.41-1.23-1.695-.42-.225-1.02-.78-.015-.795.945-.015 1.62.87 1.845 1.23 1.08 1.815 2.805 1.305 3.495.99.105-.78.42-1.305.765-1.605-2.67-.3-5.46-1.335-5.46-5.925 0-1.305.465-2.385 1.23-3.225-.12-.3-.54-1.53.12-3.18 0 0 1.005-.315 3.3 1.23.96-.27 1.98-.405 3-.405s2.04.135 3 .405c2.295-1.56 3.3-1.23 3.3-1.23.66 1.65.24 2.88.12 3.18.765.84 1.23 1.905 1.23 3.225 0 4.605-2.805 5.625-5.475 5.925.435.375.81 1.095.81 2.22 0 1.605-.015 2.895-.015 3.3 0 .315.225.69.825.57A12.02 12.02 0 0 0 24 12c0-6.63-5.37-12-12-12Z"/>
                </svg>
                Connect with GitHub
            </a>
        </div>

        <!-- User Info (shown when authenticated) -->
        <div id="user-info" class="user-info" style="display: none;">
            <div class="user-details">
                <img id="user-avatar" class="user-avatar" src="" alt="User Avatar">
                <div>
                    <div class="user-name" id="user-name"></div>
                    <div style="font-size: 14px; color: #666;" id="user-email"></div>
                </div>
            </div>
            <button class="logout-btn" onclick="logout()">Logout</button>
        </div>
        
        <!-- Main Application (shown when authenticated) -->
        <div id="main-app" style="display: none;">
            <!-- Step Indicator -->
            <div class="step-indicator">
                <div class="step-item active" id="step-indicator-1">
                    <div class="step-number">1</div>
                    <span>Repository</span>
                </div>
                <div class="step-item" id="step-indicator-2">
                    <div class="step-number">2</div>
                    <span>Issues</span>
                </div>
                <div class="step-item" id="step-indicator-3">
                    <div class="step-number">3</div>
                    <span>Agent</span>
                </div>
                <div class="step-item" id="step-indicator-4">
                    <div class="step-number">4</div>
                    <span>Progress</span>
                </div>
            </div>

            <!-- Step 1: Repository URL -->
            <div class="step active" id="step-1">
                <h2>Enter Repository URL</h2>
                <div class="form-group">
                    <label for="repo-url">GitHub Repository URL</label>
                    <div class="autocomplete-container">
                        <input type="url" id="repo-url" placeholder="Repository URL or start typing to search your repos..." required>
                        <div class="autocomplete-dropdown" id="repo-autocomplete">
                            <div class="autocomplete-loading" id="autocomplete-loading">Loading repositories...</div>
                            <div class="autocomplete-no-results" id="autocomplete-no-results" style="display: none;">No repositories found</div>
                        </div>
                    </div>
                </div>
                <button onclick="loadIssues()">Load Issues</button>
            </div>

            <!-- Step 2: Issue Selection -->
            <div class="step" id="step-2">
                <h2>Select an Issue</h2>
                <div class="search-box">
                    <input type="text" id="issue-search" placeholder="Search issues...">
                    <span class="search-icon">üîç</span>
                </div>
                <div id="issues-container">
                    <div class="loading" id="issues-loading">Loading issues...</div>
                    <div class="issues-list" id="issues-list"></div>
                    <div class="empty-state" id="no-issues" style="display: none;">
                        No open issues found for this repository.
                    </div>
                </div>
                <div style="margin-top: 20px;">
                    <button class="secondary" onclick="goToStep(1)">Back</button>
                    <button onclick="selectIssue()" id="select-issue-btn" disabled>Continue with Selected Issue</button>
                </div>
            </div>

            <!-- Step 3: Agent Selection -->
            <div class="step" id="step-3">
                <h2>Choose Coding Agent</h2>
                <div id="selected-issue-info" style="margin-bottom: 20px; padding: 15px; background: #f8f9fa; border-radius: 8px;">
                    <!-- Selected issue info will be displayed here -->
                </div>
                <div class="form-group">
                    <label for="agent">Coding Agent</label>
                    <select id="agent" required>
                        <option value="">Select an agent</option>
                        <option value="cursor">Cursor</option>
                        <option value="windsurf">Windsurf</option>
                        <option value="claude_code">Claude Code</option>
                    </select>
                </div>
                <div style="margin-top: 20px;">
                    <button class="secondary" onclick="goToStep(2)">Back</button>
                    <button onclick="startTask()" id="start-task-btn">Start Task</button>
                    <button onclick="startTask(true)" id="test-simulation-btn" style="margin-left: 10px; background-color: #17a2b8; border-color: #17a2b8;">Test Simulation</button>
                </div>
            </div>

            <!-- Step 4: Progress -->
            <div class="step" id="step-4">
                <h2>Task in Progress</h2>
                <div id="task-info" style="margin-bottom: 20px; padding: 15px; background: #f8f9fa; border-radius: 8px;">
                    <!-- Task info will be displayed here -->
                </div>
                <div class="progress">
                    <div class="status" id="status">Initializing...</div>
                    <div class="progress-bar">
                        <div class="progress-fill" id="progress-fill"></div>
                    </div>
                </div>
                <div class="pr-link" id="pr-link">
                    <strong>‚úÖ Task Complete!</strong><br>
                    <a href="#" id="pr-url" target="_blank">View Pull Request</a>
                </div>
            </div>
        </div>
        
        <div class="error" id="error"></div>
    </div>

    <script>
        // Repository Autocomplete v2.0 - Cache busting comment
        const API_BASE = 'http://localhost:8000/api';
        let currentStep = 1;
        let repoInfo = null;
        let selectedIssue = null;
        let allIssues = [];
        let currentTaskId = null;
        let progressInterval = null;
        let currentUser = null;
        let userRepositories = [];
        let autocompleteVisible = false;
        let selectedAutocompleteIndex = -1;

        // Connection attempt tracking
        const MAX_CONNECTION_ATTEMPTS = 5;
        let connectionAttempts = 0;
        let backendUnavailable = false;
        let lastConnectionError = null;

        // Connection error detection
        function isConnectionRefused(error) {
            // Check various patterns that indicate connection refused
            const errorString = error.toString().toLowerCase();
            const messageString = (error.message || '').toLowerCase();
            
            return errorString.includes('failed to fetch') ||
                   errorString.includes('network error') ||
                   errorString.includes('connection refused') ||
                   errorString.includes('net::err_connection_refused') ||
                   messageString.includes('failed to fetch') ||
                   messageString.includes('network error') ||
                   messageString.includes('connection refused') ||
                   messageString.includes('net::err_connection_refused') ||
                   (error.name === 'TypeError' && messageString.includes('fetch'));
        }

        // Connection wrapper function
        async function fetchWithConnectionLimit(url, options = {}) {
            // If backend is already marked unavailable, don't make more requests
            if (backendUnavailable) {
                throw new Error(`Backend is unavailable on ${API_BASE.replace('/api', '')}`);
            }

            try {
                const response = await fetch(url, options);
                
                // Reset connection attempts on successful connection
                if (response.status !== 0) {  // Any HTTP status means connection succeeded
                    connectionAttempts = 0;
                    lastConnectionError = null;
                }
                
                return response;
            } catch (error) {
                console.error('Fetch error:', error);
                
                // Check if this is a connection refused error
                if (isConnectionRefused(error)) {
                    connectionAttempts++;
                    lastConnectionError = error;
                    
                    console.log(`Connection attempt ${connectionAttempts}/${MAX_CONNECTION_ATTEMPTS} failed`);
                    
                    if (connectionAttempts >= MAX_CONNECTION_ATTEMPTS) {
                        backendUnavailable = true;
                        showBackendUnavailableError();
                        throw new Error(`Backend is unavailable on ${API_BASE.replace('/api', '')}`);
                    }
                }
                
                throw error;
            }
        }

        // Show backend unavailable error message
        function showBackendUnavailableError() {
            const backendAddress = API_BASE.replace('/api', '');
            const errorMessage = `üö´ Backend Unavailable\n\nThe SimulateDev backend is unavailable on ${backendAddress}\n\nAfter ${MAX_CONNECTION_ATTEMPTS} connection attempts, the frontend has stopped trying to connect.\n\nPlease:\n‚Ä¢ Check if the backend server is running\n‚Ä¢ Verify the server is accessible on ${backendAddress}\n‚Ä¢ Refresh this page once the backend is available`;
            
            showError(errorMessage);
            
            // Also log to console for debugging
            console.error(`Backend marked as unavailable after ${MAX_CONNECTION_ATTEMPTS} failed connection attempts`);
            console.error('Last connection error:', lastConnectionError);
            
            // Hide main app and show a more prominent error state
            const mainApp = document.getElementById('main-app');
            const authSection = document.getElementById('auth-section');
            
            if (mainApp) mainApp.style.display = 'none';
            if (authSection) authSection.style.display = 'none';
            
            // Create or update backend unavailable section
            let unavailableSection = document.getElementById('backend-unavailable-section');
            if (!unavailableSection) {
                unavailableSection = document.createElement('div');
                unavailableSection.id = 'backend-unavailable-section';
                unavailableSection.innerHTML = `
                    <div style="text-align: center; padding: 40px; max-width: 600px; margin: 0 auto;">
                        <div style="font-size: 64px; margin-bottom: 20px;">üö´</div>
                        <h2 style="color: #dc3545; margin-bottom: 20px;">Backend Unavailable</h2>
                        <p style="margin-bottom: 20px; line-height: 1.6;">
                            The SimulateDev backend is unavailable on <strong>${backendAddress}</strong>
                        </p>
                        <p style="margin-bottom: 30px; color: #666; line-height: 1.6;">
                            After ${MAX_CONNECTION_ATTEMPTS} connection attempts, the frontend has stopped trying to connect.
                        </p>
                        <div style="background: #f8f9fa; padding: 20px; border-radius: 8px; margin-bottom: 30px; text-align: left;">
                            <h4 style="margin-top: 0;">Please check:</h4>
                            <ul style="margin-bottom: 0;">
                                <li>Backend server is running on ${backendAddress}</li>
                                <li>Server is accessible and not blocked by firewall</li>
                                <li>No network connectivity issues</li>
                            </ul>
                        </div>
                        <button onclick="retryConnection()" style="background: #007bff; color: white; border: none; padding: 12px 24px; border-radius: 6px; cursor: pointer; font-size: 16px;">
                            Retry Connection
                        </button>
                    </div>
                `;
                document.body.appendChild(unavailableSection);
            }
            unavailableSection.style.display = 'block';
        }

        // Retry connection function
        function retryConnection() {
            console.log('Retrying connection - resetting connection state');
            
            // Reset connection tracking
            connectionAttempts = 0;
            backendUnavailable = false;
            lastConnectionError = null;
            
            // Hide backend unavailable section
            const unavailableSection = document.getElementById('backend-unavailable-section');
            if (unavailableSection) {
                unavailableSection.style.display = 'none';
            }
            
            // Hide error message
            hideError();
            
            // Show the appropriate section based on current state
            if (currentUser) {
                showMainApp(currentUser);
            } else {
                showAuthSection();
                // Attempt to check auth status again
                checkAuthStatus();
            }
        }

        // Add a helper function to reset connection state (useful for debugging)
        function resetConnectionState() {
            console.log('Manually resetting connection state');
            connectionAttempts = 0;
            backendUnavailable = false;
            lastConnectionError = null;
            
            const unavailableSection = document.getElementById('backend-unavailable-section');
            if (unavailableSection) {
                unavailableSection.style.display = 'none';
            }
        }

        // Authentication functions
        function loginWithGitHub() {
            window.location.href = `${API_BASE}/auth/github`;
        }

        async function logout() {
            try {
                await fetchWithConnectionLimit(`${API_BASE}/auth/logout`, {
                    method: 'POST',
                    credentials: 'include'
                });
                
                // Clear user data
                currentUser = null;
                
                // Show auth section, hide main app
                document.getElementById('auth-section').style.display = 'block';
                document.getElementById('user-info').style.display = 'none';
                document.getElementById('main-app').style.display = 'none';
                
                // Reset form
                resetToStep1();
                
            } catch (error) {
                console.error('Logout error:', error);
                showError('Failed to logout. Please try again.');
            }
        }

        async function checkAuthStatus() {
            try {
                const response = await fetchWithConnectionLimit(`${API_BASE}/auth/me`, {
                    credentials: 'include'
                });
                
                if (response.ok) {
                    const user = await response.json();
                    currentUser = user;
                    showMainApp(user);
                    return true;
                } else {
                    showAuthSection();
                    return false;
                }
            } catch (error) {
                console.error('Auth check error:', error);
                showAuthSection();
                return false;
            }
        }

        function showMainApp(user) {
            // Update user info
            document.getElementById('user-name').textContent = user.github_username;
            document.getElementById('user-email').textContent = user.github_email || '';
            document.getElementById('user-avatar').src = user.avatar_url || 'data:image/svg+xml,%3Csvg xmlns="http://www.w3.org/2000/svg" width="40" height="40" viewBox="0 0 24 24" fill="%23666"%3E%3Cpath d="M12 12c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4zm0 2c-2.67 0-8 1.34-8 4v2h16v-2c0-2.66-5.33-4-8-4z"/%3E%3C/svg%3E';
            
            // Show main app, hide auth
            document.getElementById('auth-section').style.display = 'none';
            document.getElementById('user-info').style.display = 'flex';
            document.getElementById('main-app').style.display = 'block';
            
            // Load user repositories for autocomplete
            loadUserRepositories();
        }

        function showAuthSection() {
            document.getElementById('auth-section').style.display = 'block';
            document.getElementById('user-info').style.display = 'none';
            document.getElementById('main-app').style.display = 'none';
        }

        async function handleAuthCallback() {
            const urlParams = new URLSearchParams(window.location.search);
            const sessionCode = urlParams.get('session_code');
            const authSuccess = urlParams.get('auth_success');
            
            if (authSuccess === 'true' && sessionCode) {
                try {
                    const response = await fetchWithConnectionLimit(`${API_BASE}/auth/session`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        credentials: 'include',
                        body: JSON.stringify({ session_code: sessionCode })
                    });
                    
                    if (response.ok) {
                        const sessionData = await response.json();
                        currentUser = sessionData.user;
                        showMainApp(sessionData.user);
                        
                        // Clean up URL
                        window.history.replaceState({}, document.title, window.location.pathname);
                    } else {
                        throw new Error('Failed to create session');
                    }
                } catch (error) {
                    console.error('Session creation error:', error);
                    showError('Authentication failed. Please try again.');
                    showAuthSection();
                }
            }
        }

        // Initialize app
        document.addEventListener('DOMContentLoaded', async () => {
            // Handle OAuth callback
            await handleAuthCallback();
            
            // Check if user is already authenticated
            if (!currentUser) {
                await checkAuthStatus();
            }
            
            // Initialize autocomplete with error handling
            try {
                setupRepositoryAutocomplete();
            } catch (error) {
                console.error('Failed to setup repository autocomplete:', error);
            }
            
            // Add debug functions to window for testing
            window.simulateConnectionError = () => {
                console.log('Simulating connection error...');
                connectionAttempts = MAX_CONNECTION_ATTEMPTS;
                backendUnavailable = true;
                showBackendUnavailableError();
            };
            
            window.resetConnection = resetConnectionState;
            
            console.log('SimulateDev Frontend loaded. Debug functions available:');
            console.log('- window.simulateConnectionError() - Simulate backend unavailable');
            console.log('- window.resetConnection() - Reset connection state');
        });

        // Step navigation
        function goToStep(step) {
            // Hide current step
            document.querySelector('.step.active').classList.remove('active');
            document.querySelector('.step-item.active').classList.remove('active');
            
            // Show new step
            document.getElementById(`step-${step}`).classList.add('active');
            document.getElementById(`step-indicator-${step}`).classList.add('active');
            
            // Mark previous steps as completed
            for (let i = 1; i < step; i++) {
                document.getElementById(`step-indicator-${i}`).classList.add('completed');
                document.getElementById(`step-indicator-${i}`).classList.remove('active');
            }
            
            currentStep = step;
            hideError();
        }

        function resetToStep1() {
            // Reset all variables
            repoInfo = null;
            selectedIssue = null;
            allIssues = [];
            currentTaskId = null;
            
            // Close WebSocket connection
            if (websocket) {
                websocket.close();
                websocket = null;
            }
            
            // Clear progress interval
            if (progressInterval) {
                clearTimeout(progressInterval);
                progressInterval = null;
            }
            
            // Reset form fields
            document.getElementById('repo-url').value = '';
            document.getElementById('agent').value = '';
            
            // Reset UI
            goToStep(1);
            hideError();
            
            // Reset progress
            document.getElementById('progress-fill').style.width = '0%';
            document.getElementById('status').textContent = 'Initializing...';
            document.getElementById('pr-link').style.display = 'none';
        }

        // Step 1: Load Issues
        async function loadIssues() {
            const repoUrl = document.getElementById('repo-url').value;
            if (!repoUrl) {
                showError('Please enter a repository URL');
                return;
            }

            try {
                hideError();
                
                // Parse repository URL
                const parseResponse = await fetchWithConnectionLimit(`${API_BASE}/github/parse-repo-url`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    credentials: 'include',
                    body: JSON.stringify({ repo_url: repoUrl })
                });

                if (!parseResponse.ok) {
                    const error = await parseResponse.json();
                    throw new Error(error.detail || 'Failed to parse repository URL');
                }

                repoInfo = await parseResponse.json();
                
                // Load issues
                document.getElementById('issues-loading').style.display = 'block';
                document.getElementById('issues-list').innerHTML = '';
                document.getElementById('no-issues').style.display = 'none';
                
                goToStep(2);
                
                const issuesResponse = await fetchWithConnectionLimit(
                    `${API_BASE}/github/repos/${repoInfo.owner}/${repoInfo.repo}/issues?state=open&per_page=50`,
                    { credentials: 'include' }
                );

                if (!issuesResponse.ok) {
                    throw new Error('Failed to fetch issues');
                }

                const issuesData = await issuesResponse.json();
                allIssues = issuesData.issues;
                
                document.getElementById('issues-loading').style.display = 'none';
                
                if (allIssues.length === 0) {
                    document.getElementById('no-issues').style.display = 'block';
                } else {
                    displayIssues(allIssues);
                }
                
            } catch (error) {
                showError(error.message);
            }
        }

        // Display issues
        function displayIssues(issues) {
            const issuesList = document.getElementById('issues-list');
            issuesList.innerHTML = '';
            
            issues.forEach(issue => {
                const issueItem = document.createElement('div');
                issueItem.className = 'issue-item';
                issueItem.onclick = () => selectIssueItem(issue, issueItem);
                
                const labels = issue.labels.map(label => 
                    `<span class="label">${label.name}</span>`
                ).join('');
                
                const body = issue.body || '';
                const truncatedBody = body.length > 150 ? body.substring(0, 150) + '...' : body;
                
                issueItem.innerHTML = `
                    <div class="issue-title">#${issue.number} ${issue.title}</div>
                    <div class="issue-meta">
                        opened by ${issue.user.login} ‚Ä¢ ${new Date(issue.created_at).toLocaleDateString()}
                        ${issue.comments > 0 ? ` ‚Ä¢ ${issue.comments} comments` : ''}
                    </div>
                    <div class="issue-body">${truncatedBody}</div>
                    <div class="issue-labels">${labels}</div>
                `;
                
                issuesList.appendChild(issueItem);
            });
        }

        // Select issue
        function selectIssueItem(issue, element) {
            // Remove previous selection
            document.querySelectorAll('.issue-item').forEach(item => 
                item.classList.remove('selected')
            );
            
            // Add selection to clicked item
            element.classList.add('selected');
            selectedIssue = issue;
            
            // Enable continue button
            document.getElementById('select-issue-btn').disabled = false;
        }

        // Continue to agent selection
        function selectIssue() {
            if (!selectedIssue) {
                showError('Please select an issue');
                return;
            }
            
            // Display selected issue info
            const issueInfo = document.getElementById('selected-issue-info');
            issueInfo.innerHTML = `
                <h3>#${selectedIssue.number} ${selectedIssue.title}</h3>
                <p><strong>Repository:</strong> ${repoInfo.owner}/${repoInfo.repo}</p>
                <p><strong>Created by:</strong> ${selectedIssue.user.login}</p>
                <p><strong>Created:</strong> ${new Date(selectedIssue.created_at).toLocaleDateString()}</p>
            `;
            
            goToStep(3);
        }

        // Start task
        async function startTask(isTest = false) {
            const agent = document.getElementById('agent').value;
            if (!agent) {
                showError('Please select a coding agent');
                return;
            }

            try {
                hideError();
                
                // Map agent to model (default to Claude 4 Sonnet for all agents)
                const agentModelMap = {
                    'cursor': 'Claude 4 Sonnet',
                    'windsurf': 'Claude 4 Sonnet', 
                    'claude_code': 'Claude 4 Sonnet'
                };
                
                const taskData = {
                    issue_url: selectedIssue.html_url,
                    agents: [{
                        coding_ide: agent,
                        model: agentModelMap[agent] || 'Claude 4 Sonnet',
                        role: "Coder"
                    }],
                    workflow_type: "custom",
                    create_pr: true,
                    issue_number: selectedIssue.number,
                    issue_title: selectedIssue.title
                };

                console.log('Sending task data:', taskData);

                const endpoint = isTest ? '/tasks/test/simulate' : '/tasks/execute';
                console.log('Using endpoint:', endpoint);
                
                const response = await fetchWithConnectionLimit(`${API_BASE}${endpoint}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    credentials: 'include',
                    body: JSON.stringify(taskData)
                });

                if (!response.ok) {
                    const error = await response.json();
                    console.error('Task execution error:', error);
                    // Handle different error formats
                    let errorMessage = 'Failed to start task';
                    if (error.detail) {
                        errorMessage = error.detail;
                    } else if (error.message) {
                        errorMessage = error.message;
                    } else if (typeof error === 'string') {
                        errorMessage = error;
                    } else {
                        errorMessage = `Failed to start task: ${JSON.stringify(error)}`;
                    }
                    throw new Error(errorMessage);
                }

                const result = await response.json();
                currentTaskId = result.task_id;
                
                // Display task info
                const taskInfo = document.getElementById('task-info');
                const simulationBadge = isTest ? '<span style="background: #17a2b8; color: white; padding: 2px 8px; border-radius: 4px; font-size: 12px; margin-left: 10px;">TEST SIMULATION</span>' : '';
                taskInfo.innerHTML = `
                    <h3>Task Started${simulationBadge}</h3>
                    <p><strong>Task ID:</strong> ${result.task_id}</p>
                    <p><strong>Repository:</strong> ${result.repo_url}</p>
                    <p><strong>Issue:</strong> #${result.issue_number}</p>
                    <p><strong>Agent:</strong> ${agent}</p>
                `;
                
                goToStep(4);
                startProgressMonitoring();
                
            } catch (error) {
                showError(error.message);
            }
        }

        // Progress monitoring with WebSocket
        let websocket = null;
        
        function startProgressMonitoring() {
            console.log('Starting progress monitoring for task:', currentTaskId);
            
            // Try to connect via WebSocket for real-time updates
            connectWebSocket();
            
            // Also start polling as fallback (every 5 seconds)
            startPollingFallback();
        }
        
        function connectWebSocket() {
            // Don't try to connect WebSocket if backend is unavailable
            if (backendUnavailable) {
                console.log('[Frontend] Backend unavailable - skipping WebSocket connection');
                return;
            }
            
            try {
                // Determine WebSocket URL based on current location
                const wsProtocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
                
                // Use the same host as the API_BASE, but extract just the host part
                let wsHost;
                if (window.location.protocol === 'file:') {
                    // If running from file://, use localhost:8000 directly
                    wsHost = 'localhost:8000';
                } else {
                    // Use current hostname and port 8000
                    wsHost = `${window.location.hostname}:8000`;
                }
                
                const wsUrl = `${wsProtocol}//${wsHost}/ws/tasks/${currentTaskId}`;
                
                console.log('[Frontend] Connecting to WebSocket:', wsUrl);
                console.log('[Frontend] Current protocol:', window.location.protocol);
                console.log('[Frontend] Current hostname:', window.location.hostname);
                console.log('[Frontend] WebSocket host:', wsHost);
                console.log('[Frontend] API_BASE for reference:', API_BASE);
                
                websocket = new WebSocket(wsUrl);
                console.log('[Frontend] WebSocket object created:', websocket);
                console.log('[Frontend] WebSocket readyState:', websocket.readyState);
                
                // Set a timeout to detect stuck connections
                const connectionTimeout = setTimeout(() => {
                    if (websocket && websocket.readyState === WebSocket.CONNECTING) {
                        console.error('[Frontend] WebSocket connection timeout - still in CONNECTING state');
                        console.error('[Frontend] Closing stuck WebSocket connection');
                        websocket.close();
                        websocket = null;
                    }
                }, 10000); // 10 second timeout
                
                websocket.onopen = function(event) {
                    clearTimeout(connectionTimeout);
                    console.log('[Frontend] WebSocket connected successfully for task:', currentTaskId);
                    console.log('[Frontend] WebSocket onopen event:', event);
                    console.log('[Frontend] WebSocket readyState after open:', websocket.readyState);
                    
                    // Send heartbeat every 30 seconds to keep connection alive
                    const heartbeatInterval = setInterval(() => {
                        if (websocket && websocket.readyState === WebSocket.OPEN) {
                            console.log('[Frontend] Sending heartbeat');
                            websocket.send('heartbeat');
                        } else {
                            console.log('[Frontend] Heartbeat interval cleared - WebSocket not open');
                            clearInterval(heartbeatInterval);
                        }
                    }, 30000);
                };
                
                websocket.onmessage = function(event) {
                    console.log('[Frontend] WebSocket message received:', event);
                    console.log('[Frontend] Message data:', event.data);
                    
                    try {
                        // Skip heartbeat responses
                        if (event.data.startsWith('heartbeat:')) {
                            console.log('[Frontend] Heartbeat response received:', event.data);
                            return;
                        }
                        
                        const data = JSON.parse(event.data);
                        console.log('[Frontend] Parsed WebSocket data:', data);
                        console.log('[Frontend] Message type:', data.type);
                        
                        // Handle different message types
                        if (data.type === 'progress') {
                            console.log('[Frontend] Handling progress update:', data.progress, data.current_phase);
                            updateProgress(data.progress, data.current_phase);
                        } else if (data.type === 'completed') {
                            console.log('[Frontend] Handling completion:', data);
                            handleTaskCompletion(data);
                        } else if (data.type === 'error') {
                            console.log('[Frontend] Handling error:', data.message);
                            handleTaskError(data.message);
                        } else {
                            console.log('[Frontend] Unknown message type:', data.type);
                        }
                        
                    } catch (error) {
                        console.error('[Frontend] Error parsing WebSocket message:', error);
                        console.error('[Frontend] Raw message data:', event.data);
                    }
                };
                
                websocket.onerror = function(error) {
                    clearTimeout(connectionTimeout);
                    console.error('[Frontend] WebSocket error occurred:', error);
                    console.error('[Frontend] WebSocket readyState on error:', websocket ? websocket.readyState : 'null');
                    console.error('[Frontend] Error event details:', {
                        type: error.type,
                        target: error.target,
                        currentTarget: error.currentTarget
                    });
                    // Fallback to polling will continue running
                };
                
                websocket.onclose = function(event) {
                    clearTimeout(connectionTimeout);
                    console.log('[Frontend] WebSocket connection closed for task:', currentTaskId);
                    console.log('[Frontend] Close event:', event);
                    console.log('[Frontend] Close code:', event.code);
                    console.log('[Frontend] Close reason:', event.reason);
                    console.log('[Frontend] Close was clean:', event.wasClean);
                    
                    // Log common close codes for debugging
                    const closeCodes = {
                        1000: 'Normal closure',
                        1001: 'Going away',
                        1002: 'Protocol error',
                        1003: 'Unsupported data',
                        1006: 'Abnormal closure',
                        1011: 'Server error',
                        1012: 'Service restart'
                    };
                    console.log('[Frontend] Close code meaning:', closeCodes[event.code] || 'Unknown code');
                    
                    websocket = null;
                    // Fallback polling will continue running
                };
                
            } catch (error) {
                console.error('[Frontend] Failed to create WebSocket connection:', error);
                console.error('[Frontend] Error details:', error.message, error.stack);
                // Fallback to polling only
            }
        }
        
        function startPollingFallback() {
            let currentInterval = 5000; // 5 seconds for fallback polling
            
            console.log('[Frontend] Starting polling fallback with interval:', currentInterval);
            
            function scheduleNextCheck() {
                console.log('[Frontend] Scheduling next polling check in', currentInterval, 'ms');
                
                progressInterval = setTimeout(async () => {
                    try {
                        console.log('[Frontend] Polling task status for:', currentTaskId);
                        console.log('[Frontend] WebSocket status check - exists:', websocket !== null);
                        if (websocket) {
                            console.log('[Frontend] WebSocket readyState:', websocket.readyState);
                        }
                        
                        const response = await fetchWithConnectionLimit(`${API_BASE}/tasks/${currentTaskId}`, {
                            credentials: 'include'
                        });
                        
                        console.log('[Frontend] Polling response status:', response.status);
                        console.log('[Frontend] Polling response ok:', response.ok);
                        
                        if (!response.ok) {
                            const errorText = await response.text();
                            console.error('[Frontend] Polling API Error:', response.status, errorText);
                            throw new Error(`Failed to get task status: ${response.status} - ${errorText}`);
                        }
                        
                        const task = await response.json();
                        console.log('[Frontend] Polling response data:', task);
                        
                        // Only update if no WebSocket connection (WebSocket has priority)
                        if (!websocket || websocket.readyState !== WebSocket.OPEN) {
                            console.log('[Frontend] Using polling data (no active WebSocket):', task);
                            console.log('[Frontend] Task progress:', task.progress, 'Task phase:', task.current_phase);
                            updateProgress(task.progress || 0, task.current_phase || task.status);
                            
                            if (task.status === 'completed') {
                                console.log('[Frontend] Task completed via polling');
                                handleTaskCompletion(task);
                                return; // Don't schedule next check
                            } else if (task.status === 'failed') {
                                console.log('[Frontend] Task failed via polling');
                                handleTaskError(task.error_message || 'Task failed');
                                return; // Don't schedule next check
                            }
                        } else {
                            console.log('[Frontend] WebSocket active, polling data ignored');
                        }
                        
                        // Continue polling
                        console.log('[Frontend] Scheduling next polling check');
                        scheduleNextCheck();
                        
                    } catch (error) {
                        console.error('[Frontend] Polling error:', error);
                        
                        // Check if backend is unavailable - if so, stop polling
                        if (backendUnavailable) {
                            console.log('[Frontend] Backend unavailable - stopping polling');
                            handleTaskError('Backend connection lost during task execution');
                            return; // Stop polling
                        }
                        
                        console.log('[Frontend] Continuing polling despite error');
                        // Continue polling despite errors
                        scheduleNextCheck();
                    }
                }, currentInterval);
            }
            
            // Start the polling loop
            console.log('[Frontend] Starting initial polling check');
            scheduleNextCheck();
        }
        
        function updateProgress(progress, phase) {
            console.log('[Frontend] updateProgress called with:', progress, phase);
            
            // Update progress bar
            const progressBar = document.getElementById('progress-fill');
            const newWidth = `${progress}%`;
            console.log('[Frontend] Updating progress bar width to:', newWidth);
            progressBar.style.width = newWidth;
            
            // Update status text
            let statusText = phase || 'Initializing...';
            if (statusText.startsWith('Status: ')) {
                statusText = statusText.substring(8); // Remove "Status: " prefix
            }
            console.log('[Frontend] Updating status text to:', statusText);
            
            const statusElement = document.getElementById('status');
            statusElement.textContent = statusText;
            
            console.log('[Frontend] Progress update complete:', `${progress}%`, statusText);
        }
        
        function handleTaskCompletion(data) {
            console.log('Task completed:', data);
            
            // Close WebSocket
            if (websocket) {
                websocket.close();
                websocket = null;
            }
            
            // Clear polling interval
            if (progressInterval) {
                clearTimeout(progressInterval);
                progressInterval = null;
            }
            
            // üéâ Trigger celebration with sound and confetti!
            triggerCelebration();
            
            // Show completion UI
            const prLink = document.getElementById('pr-url');
            const prContainer = document.getElementById('pr-link');
            
            if (data.pr_url) {
                // Check if this is a real PR URL or a search/placeholder URL
                if (data.pr_url.includes('/pull/') && !data.pr_url.includes('pull/pending') && !data.pr_url.includes('pulls?q=')) {
                    // Real PR URL
                    prLink.href = data.pr_url;
                    prLink.textContent = 'View Pull Request';
                    prContainer.innerHTML = '<strong>üéâ Task Complete!</strong><br>' + prLink.outerHTML;
                } else if (data.pr_url.includes('pulls?q=')) {
                    // Search URL for finding PRs
                    prLink.href = data.pr_url;
                    prLink.textContent = 'Search for Recent PRs';
                    prContainer.innerHTML = '<strong>üéâ Task Complete!</strong><br>PR created but URL not captured automatically.<br>' + prLink.outerHTML;
                } else {
                    // Other placeholder URLs
                    prContainer.innerHTML = '<strong>üéâ Task Complete!</strong><br>Please check the repository for recent pull requests.';
                }
                
                prContainer.style.display = 'block';
                
                // Wait 5 seconds and automatically open the PR in a new tab
                setTimeout(() => {
                    console.log('Auto-opening PR in new tab:', data.pr_url);
                    window.open(data.pr_url, '_blank');
                }, 5000);
            } else {
                // No PR URL available
                prContainer.innerHTML = '<strong>üéâ Task Complete!</strong><br>Please check the repository for any changes made by SimulateDev.';
                prContainer.style.display = 'block';
            }
            
            updateProgress(100, 'üéâ Task completed successfully!');
        }
        
        function handleTaskError(errorMessage) {
            console.log('Task failed:', errorMessage);
            
            // Close WebSocket
            if (websocket) {
                websocket.close();
                websocket = null;
            }
            
            // Clear polling interval
            if (progressInterval) {
                clearTimeout(progressInterval);
                progressInterval = null;
            }
            
            showError(errorMessage || 'Task failed');
        }

        // Search issues
        document.getElementById('issue-search').addEventListener('input', function(e) {
            const searchTerm = e.target.value.toLowerCase();
            const filteredIssues = allIssues.filter(issue => 
                issue.title.toLowerCase().includes(searchTerm) ||
                (issue.body && issue.body.toLowerCase().includes(searchTerm)) ||
                issue.labels.some(label => label.name.toLowerCase().includes(searchTerm))
            );
            displayIssues(filteredIssues);
        });

        // Error handling
        function showError(message) {
            const errorElement = document.getElementById('error');
            
            // Handle dependency-related errors specially
            if (message.includes('SimulateDev dependencies') || message.includes('modules not available')) {
                message = `‚ö†Ô∏è SimulateDev Core Dependencies Missing\n\n${message}\n\nPlease contact support or try restarting the backend server.`;
            }
            
            // Handle backend unavailable errors specially
            if (message.includes('Backend is unavailable')) {
                // The backend unavailable error will be shown in its own section
                // Don't show it in the regular error area too
                return;
            }
            
            errorElement.textContent = message;
            errorElement.style.display = 'block';
            errorElement.style.whiteSpace = 'pre-line'; // Preserve line breaks
        }

        function hideError() {
            document.getElementById('error').style.display = 'none';
        }

        // Repository Autocomplete Functions
        async function loadUserRepositories() {
            if (!currentUser || userRepositories.length > 0) return;
            
            try {
                const response = await fetchWithConnectionLimit(`${API_BASE}/auth/repositories`, {
                    credentials: 'include'
                });
                
                if (response.ok) {
                    const data = await response.json();
                    userRepositories = data.repositories;
                    console.log(`Loaded ${userRepositories.length} repositories`);
                }
            } catch (error) {
                console.error('Failed to load repositories:', error);
            }
        }

        function setupRepositoryAutocomplete() {
            const input = document.getElementById('repo-url');
            const dropdown = document.getElementById('repo-autocomplete');
            
            // Check if elements exist before setting up autocomplete
            if (!input || !dropdown) {
                console.log('Autocomplete elements not found, skipping setup');
                return;
            }
            
            // Load repositories when user is authenticated
            if (currentUser) {
                loadUserRepositories();
            }
            
            // Input event - show autocomplete as user types
            input.addEventListener('input', function() {
                const value = this.value.trim();
                
                if (value.length < 2) {
                    hideAutocomplete();
                    return;
                }
                
                // Check if user is typing a URL (starts with http or github.com)
                if (value.startsWith('http') || value.startsWith('github.com')) {
                    hideAutocomplete();
                    return;
                }
                
                showAutocomplete(value);
            });
            
            // Focus event - load repositories and show dropdown if has value
            input.addEventListener('focus', async function() {
                if (currentUser && userRepositories.length === 0) {
                    await loadUserRepositories();
                }
                
                if (this.value.length >= 2 && !this.value.startsWith('http')) {
                    showAutocomplete(this.value);
                }
            });
            
            // Blur event - hide dropdown after a delay to allow clicks
            input.addEventListener('blur', function() {
                setTimeout(hideAutocomplete, 150);
            });
            
            // Keyboard navigation
            input.addEventListener('keydown', function(e) {
                if (!autocompleteVisible) return;
                
                const items = dropdown.querySelectorAll('.autocomplete-item:not(.autocomplete-loading):not(.autocomplete-no-results)');
                
                if (e.key === 'ArrowDown') {
                    e.preventDefault();
                    selectedAutocompleteIndex = Math.min(selectedAutocompleteIndex + 1, items.length - 1);
                    updateSelectedItem(items);
                } else if (e.key === 'ArrowUp') {
                    e.preventDefault();
                    selectedAutocompleteIndex = Math.max(selectedAutocompleteIndex - 1, -1);
                    updateSelectedItem(items);
                } else if (e.key === 'Enter') {
                    e.preventDefault();
                    if (selectedAutocompleteIndex >= 0 && items[selectedAutocompleteIndex]) {
                        selectRepository(items[selectedAutocompleteIndex].dataset.repoUrl);
                    }
                } else if (e.key === 'Escape') {
                    hideAutocomplete();
                }
            });
        }

        function showAutocomplete(query) {
            const dropdown = document.getElementById('repo-autocomplete');
            const loading = document.getElementById('autocomplete-loading');
            const noResults = document.getElementById('autocomplete-no-results');
            
            // Clear previous results
            const existingItems = dropdown.querySelectorAll('.autocomplete-item:not(.autocomplete-loading):not(.autocomplete-no-results)');
            existingItems.forEach(item => item.remove());
            
            // Filter repositories
            const filtered = userRepositories.filter(repo => 
                repo.name.toLowerCase().includes(query.toLowerCase()) ||
                repo.full_name.toLowerCase().includes(query.toLowerCase()) ||
                (repo.description && repo.description.toLowerCase().includes(query.toLowerCase()))
            ).slice(0, 8); // Limit to 8 results
            
            loading.style.display = 'none';
            noResults.style.display = filtered.length === 0 ? 'block' : 'none';
            
            // Create repository items
            filtered.forEach((repo, index) => {
                const item = document.createElement('div');
                item.className = 'autocomplete-item';
                item.dataset.repoUrl = repo.url;
                
                const languageDot = repo.language 
                    ? `<div class="language-dot" style="background: ${getLanguageColor(repo.language)}"></div>`
                    : '';
                
                item.innerHTML = `
                    <div class="repo-name">${repo.full_name}</div>
                    <div class="repo-description">${repo.description || 'No description'}</div>
                    <div class="repo-meta">
                        ${repo.language ? `<div class="language-indicator">${languageDot} ${repo.language}</div>` : ''}
                        <div>Updated ${new Date(repo.updated_at).toLocaleDateString()}</div>
                        ${repo.private ? '<div>üîí Private</div>' : ''}
                    </div>
                `;
                
                item.addEventListener('click', () => selectRepository(repo.url));
                dropdown.appendChild(item);
            });
            
            dropdown.classList.add('show');
            autocompleteVisible = true;
            selectedAutocompleteIndex = -1;
        }

        function hideAutocomplete() {
            const dropdown = document.getElementById('repo-autocomplete');
            dropdown.classList.remove('show');
            autocompleteVisible = false;
            selectedAutocompleteIndex = -1;
        }

        function updateSelectedItem(items) {
            items.forEach((item, index) => {
                item.classList.toggle('highlighted', index === selectedAutocompleteIndex);
            });
        }

        function selectRepository(repoUrl) {
            document.getElementById('repo-url').value = repoUrl;
            hideAutocomplete();
        }

        function getLanguageColor(language) {
            const colors = {
                'JavaScript': '#f1e05a',
                'TypeScript': '#3178c6',
                'Python': '#3572A5',
                'Java': '#b07219',
                'C++': '#f34b7d',
                'C': '#555555',
                'C#': '#239120',
                'Go': '#00ADD8',
                'Rust': '#dea584',
                'Ruby': '#701516',
                'PHP': '#4F5D95',
                'HTML': '#e34c26',
                'CSS': '#1572B6',
                'Swift': '#ffac45',
                'Kotlin': '#7F52FF',
                'Dart': '#00B4AB',
                'Shell': '#89e051'
            };
            return colors[language] || '#95a5a6';
        }

        // Confetti Animation Functions
        function createConfetti() {
            const confettiContainer = document.createElement('div');
            confettiContainer.className = 'confetti-container';
            document.body.appendChild(confettiContainer);

            const colors = ['#ff6b6b', '#4ecdc4', '#45b7d1', '#96ceb4', '#feca57', '#ff9ff3', '#54a0ff', '#5f27cd'];
            const shapes = ['square', 'circle', 'triangle'];
            
            // Create multiple bursts of confetti
            for (let burst = 0; burst < 3; burst++) {
                setTimeout(() => {
                    for (let i = 0; i < 50; i++) {
                        createConfettiPiece(confettiContainer, colors, shapes);
                    }
                }, burst * 200);
            }

            // Remove confetti container after animation completes
            setTimeout(() => {
                document.body.removeChild(confettiContainer);
            }, 4000);
        }

        function createConfettiPiece(container, colors, shapes) {
            const confetti = document.createElement('div');
            confetti.className = 'confetti-piece';
            
            // Random shape
            const shape = shapes[Math.floor(Math.random() * shapes.length)];
            confetti.classList.add(shape);
            
            // Random starting position
            confetti.style.left = Math.random() * 100 + 'vw';
            
            // Random size variation
            const size = Math.random() * 8 + 6; // 6-14px
            if (shape !== 'triangle') {
                confetti.style.width = size + 'px';
                confetti.style.height = size + 'px';
            }
            
            // Random animation duration and delay
            const duration = Math.random() * 2 + 2; // 2-4 seconds
            const delay = Math.random() * 0.5; // 0-0.5 second delay
            confetti.style.animationDuration = duration + 's';
            confetti.style.animationDelay = delay + 's';
            
            // Random rotation speed
            const rotationSpeed = Math.random() * 360 + 360; // 360-720 degrees
            confetti.style.setProperty('--rotation', rotationSpeed + 'deg');
            
            container.appendChild(confetti);
        }

        function triggerConfetti() {
            console.log('üéâ Triggering confetti animation!');
            createConfetti();
            
            // Add some extra celebration with a slight delay
            setTimeout(() => {
                createConfetti();
            }, 500);
        }

        // Sound effect function
        function playCompletionSound() {
            try {
                const audio = new Audio('windows_complete.mp3');
                audio.volume = 0.7; // Set volume to 70%
                
                // Play the sound
                audio.play().catch(error => {
                    console.log('Could not play completion sound:', error);
                    // Fallback: try to play a system beep or notification sound
                    try {
                        // Create a simple beep using Web Audio API as fallback
                        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                        const oscillator = audioContext.createOscillator();
                        const gainNode = audioContext.createGain();
                        
                        oscillator.connect(gainNode);
                        gainNode.connect(audioContext.destination);
                        
                        oscillator.frequency.value = 800; // 800Hz tone
                        gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);
                        
                        oscillator.start(audioContext.currentTime);
                        oscillator.stop(audioContext.currentTime + 0.5);
                    } catch (fallbackError) {
                        console.log('Fallback sound also failed:', fallbackError);
                    }
                });
            } catch (error) {
                console.log('Error setting up completion sound:', error);
            }
        }

        function triggerCelebration() {
            console.log('üéâ Triggering celebration!');
            
            // Play sound first
            playCompletionSound();
            
            // Then trigger confetti
            triggerConfetti();
        }

        // Test sound function for manual testing
        function testSound() {
            console.log('üîä Testing completion sound...');
            playCompletionSound();
        }
    </script>
</body>
</html> 